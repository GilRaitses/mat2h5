<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MAGAT FAIRY - MATLAB to H5 Conversion Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
            background: #7fff00; /* Chartreuse */
            color: #000000;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
        }
        
        #canvas-container canvas {
            background: transparent !important;
        }

        #content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
            padding: 2rem;
            pointer-events: none;
        }

        #content > * {
            pointer-events: auto;
        }

        h1 {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #ff6b35 0%, #667eea 50%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            color: #333333;
            font-weight: 300;
            animation: fadeInUp 1s ease 0.5s both;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .description {
            font-size: 1.1rem;
            max-width: 600px;
            margin-bottom: 2rem;
            color: #222222;
            line-height: 1.6;
            animation: fadeInUp 1s ease 0.7s both;
        }

        .buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            animation: fadeInUp 1s ease 0.9s both;
        }

        .btn {
            padding: 0.75rem 2rem;
            font-size: 1rem;
            border: 2px solid #000000;
            background: transparent;
            color: #000000;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .btn-primary {
            background: transparent;
            color: #000000;
            border: 2px solid #000000;
        }

        .btn-primary:hover {
            background: rgba(0, 0, 0, 0.1);
        }




        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #7fff00; /* Chartreuse */
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
            overflow: hidden;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .fairy-art {
            font-family: 'Courier New', monospace;
            font-size: 8px;
            line-height: 1;
            white-space: pre;
            color: #000;
            position: relative;
            z-index: 2;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
            animation: fadeInFairy 1s ease-in;
        }

        @keyframes fadeInFairy {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .loading-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Avenir Next Ultra Light', 'Avenir Ultra Light', 'Avenir Next', 'Avenir', sans-serif;
            font-size: 24px;
            font-weight: 200;
            color: #000;
            z-index: 3;
            text-shadow: 0 0 4px rgba(127, 255, 0, 0.6);
            opacity: 0.9;
            letter-spacing: 2px;
        }

        .loading-progress-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Avenir Next Ultra Light', 'Avenir Ultra Light', 'Avenir Next', 'Avenir', sans-serif;
            font-size: 14px;
            font-weight: 200;
            color: #000;
            z-index: 3;
            text-shadow: 0 0 3px rgba(127, 255, 0, 0.5);
            opacity: 0.8;
        }

        .fairy-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 400%;
            height: 400%;
            background: conic-gradient(
                from 0deg,
                #ff6b35 0%,
                #ff7a45 10%,
                #fbbf24 20%,
                #f9d371 30%,
                #7fff00 40%,
                #8fff33 50%,
                #7df9ff 60%,
                #8dfaff 70%,
                #667eea 80%,
                #6f7feb 90%,
                #764ba2 100%,
                #8a5fb8 110%,
                #ff6b35 120%
            );
            background-size: 200% 200%;
            animation: swirlGradient 10s linear infinite;
            mix-blend-mode: soft-light;
            opacity: 0.2;
            filter: blur(40px);
            z-index: 1;
            pointer-events: none;
        }

        @keyframes swirlGradient {
            0% {
                background-position: 0% 0%;
                transform: translate(-25%, -25%) rotate(0deg);
            }
            50% {
                background-position: 100% 100%;
                transform: translate(-25%, -25%) rotate(180deg);
            }
            100% {
                background-position: 0% 0%;
                transform: translate(-25%, -25%) rotate(360deg);
            }
        }

        .fairy-container {
            position: relative;
            display: inline-block;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            .subtitle {
                font-size: 1.2rem;
            }
            .description {
                font-size: 1rem;
            }
            .label {
                font-size: 0.75rem;
                padding: 0.4rem 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="fairy-container">
            <div class="fairy-gradient"></div>
            <div class="loading-title">MAGAT FAIRY</div>
            <div class="fairy-art" id="fairy-art"></div>
            <div class="loading-progress-text" id="loading-progress-text">Loading...</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    
    <div id="content">
        <h1>MAGAT FAIRY</h1>
        <p class="subtitle">MATLAB to H5 Conversion Tool</p>
        <p class="description">
            Transform your MAGAT experiment data from MATLAB's structured format 
            into Python-ready H5 files. Watch the data flow through our conversion pipeline.
        </p>
        
        <div class="buttons">
            <a href="https://github.com/GilRaitses/mat2h5" class="btn btn-primary">View on GitHub</a>
            <a href="https://github.com/GilRaitses/mat2h5#quick-start" class="btn">Get Started</a>
            <a href="https://github.com/GilRaitses/mat2h5/blob/main/README.md" class="btn">Documentation</a>
        </div>

    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // Loading progress
        const loadingScreen = document.getElementById('loading-screen');
        const fairyArt = document.getElementById('fairy-art');
        const loadingProgressText = document.getElementById('loading-progress-text');
        
        // Load fairy ASCII art
        const fairyASCII = `⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢠⠠⡀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠡⢣⠱⡘⢬⢠⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠐⠀⠀⠀⠀⠀⠀⠀⢀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢑⢕⢍⢎⢪⡘⢜⢰⢠⢀⠐⠀⠀⠀⢀⠀⠀⠀⠀⢀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⢀⠀⠄⠀⠀⢀⠠⠀⠀⠠⠀⠂⠄⠀⠀⢀⠀⠈⠀⠂⠠⠀⠀⠀⠀⠐⠀⡀⠄⠀⠀⠄⠂⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠐⠀⠁⠀⠀⠀⠑⢕⢜⢜⡜⡜⡔⡑⢕⠢⡢⡀⡀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⡀⠈⡀⠀⠀⠠⠀⠀⠠⠀⠄⠠⠀⠀⠀⠀⠠⠀⠄⠀⢀⠀⠀⠀⠂⠀⠀⠈⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠂⠀⠀⠂⠀⠀⠂⠀⠀⠂⠀⠀⠂⠀⠀⠂
⠀⠀⠀⠀⠀⠀⠀⠀⠱⡱⣱⢕⡇⡧⡙⢔⢅⢂⢂⠒⡐⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⡐⠁⠀⠀⠀⠅⢈⠀⠠⠊⠀⢀⠀⠂⠀⠀⠀⠂⠐⠀⠠⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢪⢎⢗⢵⢱⢨⠢⠡⡑⠔⡐⡈⠌⠨⡠⢀⠀⠀⠀⠀⠄⠀⠀⠀⠈⠄⠄⠀⠀⠀⠀⠂⠄⢀⠀⠠⠀⡀⠌⢀⠈⠐⢄⠑⠄⢁⢐⠄⠂⢀⠈⠠⠈⠀⠅⠈⠠⠀⠂⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠨⡪⡲⡑⡥⢕⠨⢂⠂⢅⠂⡂⡊⢌⢂⠅⢂⠄⠀⠠⠐⠀⠀⠀⠀⠀⠀⠐⠈⡈⠄⢀⠀⠀⠨⢀⢐⠐⡐⢀⢂⠐⡀⠌⡢⠈⡐⣐⢕⢔⢌⢆⡒⢔⠔⣀⢀⠨⡀⠀⠐⠠⠈⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢀⠀⠀⠀⠀⠀⠀⠂⠁⠀⢇⢎⢎⠪⡊⢜⠰⡑⠄⠅⢂⠈⡂⠢⢊⢐⠨⢐⠀⡀⠀⠀⠀⢀⠀⠀⠀⡁⠀⠐⠀⠄⠀⢈⠐⡐⠨⠨⢀⠂⡂⠢⡑⡌⢆⢪⡪⡚⢸⢸⢸⢸⢨⠪⡐⣕⢑⠔⡌⠠⠡⢑⠨⠠⠁⠀⠀⠀⢀⠁⠀⠀⠐⠀⠈⠀⠀⠀⠠⠀⠀⠠⠀⠀⠠⠀⠀⠠⠀⠀
⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠈⢆⢇⢕⢜⢜⠨⡂⢍⠪⡐⡐⠠⠁⢅⠢⡈⡢⠡⡠⠀⠀⠀⠀⠀⠀⠀⠄⢈⠠⠁⠌⡐⠀⢄⠈⠌⡈⡢⡐⢬⢺⢸⢸⡸⡨⣐⡄⡇⢅⢢⠳⡝⢧⢢⢃⠢⡑⠌⡊⢌⠀⡈⠄⢀⠂⢀⠁⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢕⢕⢔⢌⢎⡪⡪⡢⡃⢌⠢⡈⠌⡀⠂⡒⠄⠅⠂⠅⢅⢀⠀⠀⠀⡈⠠⠠⠀⠂⠁⠄⢅⠂⢄⢂⢆⢢⢪⢪⢳⢡⢊⢇⡃⡱⣹⢸⠨⡊⢎⢞⣜⠌⠪⡪⡢⡘⡜⢠⢊⢐⠐⡀⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢀⠀⠀⢀⠀⠀⠀⠀⠀⢸⢔⢕⢱⠱⡑⢕⠡⠣⡑⡑⢔⠡⠀⢂⠠⠑⡈⠠⠁⡂⡑⢄⠀⠀⡀⠂⠄⠡⠨⢂⠣⡑⢥⠱⡐⡌⡎⡗⡵⡹⡵⡱⣜⢽⡹⡐⡱⡵⣜⢮⣪⡪⡪⡮⣐⢵⢱⢨⢪⠐⢔⠡⠠⠀⠂⠡⠁⠠⠀⠄⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠄⠀⢀⠀⠀⠀⠀⠀⠁⠀⢘⡎⡆⡇⢕⠨⡂⠕⡁⡂⡂⠢⢑⠑⢄⠐⡈⠄⡀⠁⠄⡀⢂⠑⢄⠀⠌⠀⠅⢐⠐⢐⠠⡑⢌⢊⢎⡮⣧⡳⡵⡯⡯⣏⢕⡬⣲⢽⣙⢎⢯⢺⡪⢯⢚⠝⠜⠌⡒⡅⡁⠢⡡⠨⠐⠀⠀⠂⠁⠁⠀⠀⠀⠀⠀⠐⠈⠀⠀⠀⠂⠈⠀⠀⠀⠀⠠⠀⠀
⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠐⢕⢵⢱⢁⠢⡈⡂⢆⢂⠊⢌⠐⡈⠀⠅⢂⠡⠀⠐⠀⠐⠠⢈⠢⡂⠌⠐⠈⡀⠐⡀⢂⠎⡎⣎⡞⣞⡵⡏⡎⡎⢯⢯⢗⡯⡏⡗⡞⠮⡪⡑⡘⠐⡐⠌⡪⢸⢺⢸⢠⠁⡂⢁⠀⠁⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⢁⠣⡣⡑⠔⡐⠌⡂⡢⢈⠐⢐⠀⠅⢈⠠⠈⠌⢄⠂⠁⠌⠠⢊⠌⡆⡁⠄⢐⢀⠂⡂⢑⡱⡕⡯⣺⣝⣯⢂⢏⢮⢏⢧⢓⠕⡑⠌⢆⢄⠄⠐⡀⠂⠡⠂⡕⣇⢗⢥⢑⢐⠐⠨⠀⡀⠀⠀⠀⠀⠀⠀⠠⠐⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⢀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠌⡂⠕⡱⠰⡁⡊⡐⡐⡡⡀⡂⠁⠄⠠⠈⡨⠐⢌⢌⢐⠨⠐⢌⢪⠢⡐⢀⢂⠂⡬⡢⡺⡪⡯⣺⣺⣺⣕⣕⢝⡜⠜⢄⠱⣐⢈⢀⠂⠅⡁⠠⢈⠨⢐⢸⣳⢱⡑⠅⠐⢈⠠⠀⠀⠂⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⡀⠀
⠀⠀⠀⠀⠀⠀⠀⠄⠂⠀⠈⠀⠀⠀⠠⠡⡂⢕⠨⡐⠨⡐⠔⢌⢐⠠⡈⠄⢂⠐⠈⠄⠱⡐⠨⢌⠢⡡⡑⡆⡢⡐⢜⢜⢘⢮⡫⣳⢯⡺⣺⣺⣺⢸⢨⢑⠡⠈⠌⡑⠡⠈⠄⢐⠌⡂⢍⢊⣞⣮⢳⠌⡊⠄⠠⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠀⠄⠀⠀⠀⠀⠀⠠⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠠⢑⠨⠐⡐⠀⠅⠐⡈⠠⠀⡂⢈⠈⡐⠨⠠⢁⠐⡨⢨⠨⢚⢜⢜⡜⡼⡘⡌⡪⣜⢮⣻⣺⣳⡹⣕⣗⢧⢣⢑⠐⡈⠈⠄⠂⡈⠄⠂⢅⠱⢪⣪⢟⢾⢸⠱⡑⠨⠠⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⡀⠀⠀⠂⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠪⠨⡐⠠⡁⠈⠄⢐⠈⠠⠀⠂⠠⠀⠌⢈⢐⢐⢐⠠⠱⣐⢱⢱⢳⡹⣆⢇⢧⢳⡹⡮⣺⡪⣞⢮⢺⢵⢱⢁⢂⠐⢈⠀⠄⢂⠄⢕⠐⢌⡲⣝⡇⡏⣪⠣⡊⠄⡑⠀⠀⠀⡀⠀⠀⢀⠀⠀⠀⠀⠀⠀⡀⠁⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠄⠀⠂⠁⠀⠁⠄⠀⠀⠀⠀⢁⠣⡈⠢⢐⠀⠂⢄⠈⡀⠡⢈⠠⡈⡐⡀⡂⠔⡐⡡⠡⡂⡧⡳⣹⡪⡷⣕⡽⣕⢽⢝⣜⢮⡗⡗⡭⣳⢱⢱⣐⢀⠂⡈⡂⠆⠌⢄⡼⡼⣝⡜⣞⠔⡕⢅⠂⠔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⡀⠄⠁⠀⠀⠀⠊⠌⡢⢁⠁⢁⠐⠀⡁⠄⠂⠠⢈⢐⠨⡈⡢⠪⡪⡊⡎⡮⡳⡽⣽⡺⣜⢮⣫⣛⢞⢝⢜⠎⡎⢮⠪⣒⢮⣖⣄⣂⣔⢵⣫⡯⣯⣟⢮⢺⠸⡘⡜⠐⠀⠂⠀⠈⠀⠀⠀⠠⠀⠀⠀⠠⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⡀⠄⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠈⠀⠀⠠⠀⠂⠐⡈⠠⢀⠂⠄⠂⠨⠐⠠⢂⢢⠪⡰⠱⡰⡪⡪⢮⢮⣟⣞⢮⢃⠃⡂⢘⠸⢸⢐⢱⠸⡘⢌⢮⢳⡣⣗⣽⣪⢿⡵⣯⡳⣯⡳⡝⡕⡅⡣⡁⠀⡀⠁⠐⠀⠀⠀⠀⠀⠀⠀⠀⠂⠠⠀⠀⠀⠀⠈⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⠈⠀⠄⠀⢀⠀⠀⠠⠐⠀⠀⠀⠀⠀⠀⠁⠁⠊⠐⠅⠥⡑⡡⡑⡠⣃⢌⣎⢦⢵⢽⢽⡳⡳⡣⠑⡀⠂⠠⠐⢈⠐⢱⢑⢑⠅⡱⡑⢔⢑⠱⡱⡫⣯⡻⡮⡯⣺⣪⠣⡑⢕⢅⢂⠁⢀⠀⠀⠀⠀⠀⠐⠀⠀⠐⠀⠁⠄⠐⠀⠁⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠂⠀⠀⡀⠀⠀⠂⠁⠀⠀⠠⠀⡐⣀⢅⢴⡸⣜⡞⡮⣗⢯⢯⢯⢯⡳⡹⡘⠠⠁⠄⢈⠀⠂⡐⠈⠄⡣⠂⠅⡢⢈⠂⢅⠑⠌⢜⢸⡺⣝⢮⡳⡱⣑⠨⡂⡢⠁⡊⠄⡠⠀⠁⠀⠀⠀⠀⡁⠀⠀⠀⠠⠀⠀⠄⠂⠠⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡐⠠⠀⠀⠀⠠⠀⢀⢄⠬⡢⢣⢣⠣⡋⡇⡫⠪⡸⡜⡎⡯⡾⣽⡳⡽⣘⠨⠠⠁⠌⡀⠄⢁⠠⢈⠐⡨⡊⡐⢀⠂⠌⡐⢨⠨⢂⠢⢯⢯⡳⡝⡜⡔⢕⡑⢄⠐⠀⠀⡂⡀⠂⠀⠀⠈⠀⠀⠂⠀⠀⠂⠀⠅⠂⠈⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠁⠀⠀⠁⠀⠀⠐⠠⠡⠀⠀⠄⡂⡊⡢⡱⢑⠅⢕⠡⢃⠪⡐⡕⡍⢇⢕⢽⢽⢝⡾⣝⡎⡆⠌⠄⠅⠂⠄⠂⠄⡠⢂⠆⡆⡣⣂⠂⠌⠐⡐⡐⢅⠢⢑⢝⡵⡫⣎⢎⢪⢢⢑⢑⠌⠄⠂⢂⠄⠠⠀⠀⡀⠀⠈⠈⠄⠐⡈⢈⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠁⠀⠀⠀⠀⠀⠀⠡⠐⢐⢀⠈⡀⢀⢆⢇⢕⢜⢌⠌⡢⢑⠡⡨⣐⠬⡊⢎⢌⢪⢺⢪⡪⡫⣞⣕⢇⢣⢑⠨⡨⢨⠰⡑⡕⡸⡐⡕⡪⢪⢸⠨⡨⢐⢀⢇⠥⡱⡐⡕⢽⣱⡣⡏⡎⡆⠕⡔⡡⢑⠁⡐⠀⠀⠀⡀⠀⠀⠀⠀⠁⠄⠀⠀⠀⠀⡀⠐⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀
⠠⠀⠀⠀⠀⠀⠂⠀⠀⠀⠈⠄⠂⠅⡐⠀⢀⢢⠱⡐⢅⢂⠆⡢⢑⠰⡘⠌⢌⢆⢆⢗⢝⡜⣎⢯⣺⢜⢜⠰⡐⡕⡎⡇⡇⡣⡊⡢⡱⢌⠢⡅⢕⢱⢌⢂⢪⡪⡮⡪⣪⢪⢪⢲⢕⢕⢕⢕⠕⢌⠆⡂⠅⠄⠀⠀⠁⢀⠐⠀⠀⠂⠀⠄⠠⠐⢀⠁⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠠
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠂⢐⢅⠣⡪⡢⡡⠨⡠⡑⠡⡁⠅⠕⡡⢱⢱⢱⢝⢜⢵⡳⡱⡡⣣⢣⢣⡳⣱⢹⢨⠢⡪⡪⢸⠨⢈⢂⠪⡱⡡⡓⡜⡵⡝⡜⡜⢜⢎⢮⢣⢣⠣⢅⢣⢑⠨⠈⠄⠀⠁⠀⠀⠐⠈⢀⠀⠂⢐⠐⠈⠀⡀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⡀⠄⠈⠀⠀⠠⠀⠀⢈⠢⡑⢅⢊⢐⠨⡐⠢⠨⠨⠠⠡⡡⢊⠎⡊⡮⠢⡱⣳⢽⡪⡯⣪⢳⢱⢕⢕⢇⠕⡕⡕⡑⡌⡢⠁⠄⠡⠨⢸⢸⢸⣸⢱⠸⡘⢌⠪⡊⢎⠆⡝⢌⠂⡂⡂⠈⠠⠈⢀⠀⠈⠀⠅⠄⢀⠂⠀⠀⡀⠀⠀⠀⠀⢀⠐⡈⡠⠀⠀⠠⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠂⠁⢀⢇⠪⢐⢀⢂⠊⢄⠡⠡⠡⡑⡑⢌⢂⠊⠈⡎⡎⡮⡳⣫⢎⢇⢇⢕⢎⢾⢝⡎⣞⢜⢜⢜⢐⠌⠌⢌⠌⠌⢂⠐⠠⠐⡈⠌⡈⡂⢣⠡⡣⢑⠌⡢⠡⢀⠂⠄⠀⠌⢀⠀⠂⠁⢀⠁⡂⠀⠈⠀⠀⠂⠀⠈⠀⠀⠐⠀⠄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⠀⠨⢈⠀⠀⠄⠀⢀⠀⡕⡑⠅⡂⢅⠊⠄⡪⠨⡐⡐⠌⠀⠄⠠⠡⡪⡪⠪⣪⡳⡝⣜⢕⢕⢵⣫⣳⡹⣎⢎⣞⢧⡱⢘⠨⠀⡐⢀⠂⠨⠠⡡⡂⠅⢂⠂⡑⠨⠈⡂⠌⠂⠡⢀⠂⡈⢐⠀⠄⠂⠀⠂⢀⠀⡂⢀⠁⠀⠁⠀⠀⠀⠈⠄⠈⠀⡀⠀⠀⠀⠀⠀⠀
⠀⠀⢀⠀⠀⠈⠀⠀⠀⠐⠀⡐⠈⠀⠀⢀⢕⠌⡢⠨⡐⡨⢪⡘⡌⠊⠀⠀⠄⠅⠕⡑⠕⡑⢕⢕⢧⡫⣎⢎⢮⡳⣵⡳⡽⣝⣞⣞⡵⠨⢐⠄⡁⡐⠠⠈⢄⠇⢂⠐⠈⡀⠄⢀⠂⢁⢀⢂⠁⠅⠂⠐⡀⠄⠂⠠⠈⠄⢁⠂⡐⠀⠄⠀⠈⠀⠀⡀⢈⠀⠠⠁⠅⠀⠀⠀⠀⠀⠀⠀
⠀⠁⠀⠀⠀⠀⠂⠐⠠⠀⠐⡀⠈⠀⠀⡐⢅⠪⡐⢕⢌⠎⠂⠐⠀⠈⠔⠀⠨⠨⠐⠨⢂⠨⢪⡫⣞⢜⢮⡪⡇⡧⣳⢽⢺⢵⣳⣳⠡⢸⢂⢂⠆⢂⠅⣊⠢⢁⠂⠄⡁⠄⡐⡠⢬⢒⢌⠢⠩⢊⠨⠀⠄⠠⠈⡀⠅⠐⠀⡂⢂⠁⠄⠈⠄⠈⠀⠀⠀⡂⠀⠄⠀⠀⠀⠀⠀⡀⠄⠈
⠀⠀⠀⠀⠀⠀⠀⠁⠄⡑⡀⠠⠠⢁⠀⢌⠢⡑⠌⠊⠀⠂⠄⠁⠄⠂⠁⠄⠂⠡⢀⠡⢑⢄⢷⢹⢜⣕⢗⢕⢝⢎⢇⣗⢯⣳⣳⣳⢧⢵⡰⣅⡪⡌⡢⡑⢌⢐⠌⣂⠦⡕⡕⢍⠢⢑⠡⠨⠨⡐⢌⠪⡀⢂⠐⡀⠄⢁⢁⠂⠠⠐⠀⡈⠀⠀⠂⡁⢀⠂⠈⠀⠀⠀⠀⠀⠁⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠡⠀⠀⡢⡑⠌⠀⠈⠀⠠⠐⢈⠀⠈⢂⠅⠀⠄⠂⠄⢂⡳⡝⣕⢗⢕⢱⢱⡱⣱⢝⡮⣟⣞⣾⣺⢯⢯⢟⡮⣟⢮⣳⢬⡢⡳⡹⡪⡣⡣⣊⠢⡊⡐⠨⡈⡂⡂⡢⠱⡌⠄⡂⠄⢂⠐⡐⠈⡀⡪⢐⠀⠂⢁⠀⡂⠂⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⠀⡀⡀⢈⠐⠀⢌⠢⠂⠀⠈⡈⡐⠠⠠⠐⡀⢡⢀⠪⡐⠀⠨⠐⡔⡕⡕⢕⢜⢜⢮⢳⢝⢮⢯⣟⢾⣳⣳⡫⡏⣗⡽⣎⢯⢫⢎⡇⡇⡇⡏⢜⢜⡜⣆⠣⡂⡊⢌⠔⡐⢔⢐⠡⢣⢃⠢⡈⠄⢂⢂⠡⢀⢂⠁⠄⠁⢂⠂⠐⠀⠂⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠐⠀⠀⠄⠀⠂⠈⠨⡠⠁⠀⡀⠂⠀⠂⠅⡂⡡⠂⠀⠡⢑⠀⡐⠨⢸⢸⢘⢌⠎⡎⣎⢮⡺⡽⡹⡕⡕⣕⢧⢣⢫⢺⠸⣚⢜⢜⢜⡜⣎⢮⢪⢪⡪⡣⡎⡆⣇⠪⡐⣁⠢⠡⠡⡢⢑⠱⣑⢑⠔⡈⡐⡐⠄⡁⠄⠂⠠⠁⠄⡀⠂⠁⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢨⠨⠀⠈⢀⠠⠀⠐⠀⠁⠠⠐⠡⡈⡀⢂⠅⠠⢡⢣⠣⡊⡎⡞⡪⡪⣇⢏⢎⢎⠪⡊⡮⡣⡣⡣⡣⡣⡣⡊⢆⡣⡣⣫⡪⡮⡪⡞⣎⢗⢝⡜⡜⡔⢔⢐⠅⢕⠱⡨⠢⡑⠥⡑⡌⢆⠢⠈⠄⡐⠈⠄⡁⠈⠀⡀⠄⠀⠀⠠⠐⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠠⠀⠀⠀⠂⠀⠀⠂⠀⠈⢄⠃⠀⠄⠐⠀⠄⠁⠀⠂⡑⠄⢈⠐⡐⠠⢂⠊⢌⡢⡣⢣⢣⢣⢣⢣⢏⢖⢑⢌⢢⢑⠜⡜⡌⡆⡇⡇⡪⡨⡪⡪⡺⣪⡺⣜⢞⣝⢮⢯⢇⢇⡓⢌⠢⡑⠍⡂⢅⢇⠣⡊⢎⢎⢌⠢⠣⡁⢂⠢⠁⡁⠠⠈⡀⠄⡐⠀⠁⠀⠠⠐⠀⠀⠀⠀⠀⠁⠀
⠀⠀⠀⠀⠀⠀⠀⠀⡀⠄⠕⠁⠀⠁⠄⠀⠠⠈⢀⠁⢀⠐⡀⠄⠂⢨⠈⠔⢌⢢⢣⢕⢅⠣⡱⡱⡕⢕⠢⡑⡐⢕⢔⢱⠡⡣⡃⡇⢕⢔⢕⢅⢇⢯⡳⣕⢗⡽⣞⡽⡝⡕⡱⡨⠢⡑⢌⠆⢌⠢⡢⣃⢪⠰⡱⡐⢅⠣⡑⠔⠐⡀⠄⠀⢂⠢⡁⠂⠀⡀⠈⢀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠠⠀⠐⠀⠐⠀⠀⡀⠐⡀⢂⠈⢀⠂⠄⡈⠄⢀⠢⡢⡡⢂⢂⠡⡱⣱⢱⢸⠰⡑⢜⢜⢜⠸⡨⡂⡣⡱⡐⢕⢱⢑⢜⢜⡜⡜⡔⣕⢝⡽⣺⢵⢯⡯⣗⢯⢳⢱⢑⠕⡑⡌⡢⢑⢐⠅⡣⡊⡆⡣⠪⡸⡐⡑⢌⢊⢆⠠⠡⡁⡂⠅⠀⠂⠀⢂⠈⠀⠀⠀⠀⠀⠀⠠⠀⠀
⠀⠐⠀⠀⠠⠀⠂⠁⠀⠀⠂⠀⠀⠀⠄⠂⠰⠀⠅⠠⢑⠠⡣⢣⢊⢢⢱⠠⢣⢇⢇⢇⢇⢇⢇⢎⢆⢣⠱⡌⡆⢎⢜⢜⢜⣜⢎⢧⢣⢣⡳⣕⢯⣫⢏⣯⢯⡯⡯⡪⡎⡪⡰⢡⢃⠕⢄⢑⠄⢕⢱⢱⢘⠜⡌⡎⡆⢕⠡⡂⠆⢅⠅⡊⡐⠀⠌⠠⠡⠠⢀⠀⠀⠀⠀⠀⡀⠀⠀⠀
⠀⠀⡀⠠⠀⠀⡀⠀⠀⠐⠀⠂⠀⠠⠐⢈⠨⡈⢌⠨⠠⢑⢜⠰⡡⡑⢔⢕⢕⢯⡪⡎⡎⡎⡎⡎⡎⡎⡎⡎⡊⢎⢜⢜⢎⢮⢳⡱⣕⢯⢾⢵⣻⢮⣻⢾⢽⣝⢎⢮⢊⠢⡣⡑⢆⢑⠔⠡⠨⡐⡱⡡⢕⢜⢸⢸⢸⢘⢌⢌⠪⡐⡐⡀⠂⠁⠀⠂⠠⠀⡀⠀⠁⠠⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠠⠀⠠⠐⠀⠂⡂⢕⠠⠑⠄⠕⡕⡌⢎⡆⡇⡇⣟⢎⢎⢎⢎⢎⢎⢎⢎⢎⡇⡇⡧⡳⣹⡱⣝⢞⣞⡽⣝⡯⣳⣻⡺⡽⣝⢎⢇⢇⠕⢅⢇⢕⢡⢑⢌⠪⢐⢌⠢⡣⡣⡱⢱⢱⢱⢱⢱⢂⢇⢂⢂⢂⠂⡈⢀⠠⠈⡐⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠂⠀⠀⠀⠀⠀⠀⠄⠄⡂⠢⠨⠠⢂⢈⠐⡐⢔⠡⡁⠪⠨⡘⡜⢼⡪⡇⡇⡇⡣⡪⣪⢪⢪⢪⡪⣪⡪⣪⢺⡸⡪⣝⠜⣪⢗⣯⢷⢯⣗⢯⡺⣪⢾⡹⡪⡪⡣⢣⢱⢱⠱⡡⡑⡌⡢⢑⢐⠔⡡⢱⢱⢱⢱⠱⡱⡱⣑⢢⢑⢢⢂⠐⡈⠄⠀⠀⠀⡀⠁⠄⠀⠀⠀⠀⠀⠀⠀⡀
⠀⠀⠀⠀⠀⠀⠀⠈⠀⠁⡂⠅⠅⠕⡐⠄⢅⠢⡂⠅⢅⢇⢕⢱⢨⢢⢪⠮⡎⡎⣆⢯⣪⢺⢜⡜⣜⢴⢹⣪⣣⡳⣝⢜⡢⣗⢯⡺⣽⢳⡣⣗⢝⢮⡣⡣⡣⡣⡣⡣⡳⡱⡑⢌⢢⠱⡈⡢⢂⢊⠔⡡⢱⢵⢱⢑⢕⢕⢕⡅⢇⠆⡢⠡⡐⠨⡀⠁⠀⠀⠀⠀⠀⠀⠀⡀⠀⠂⠀⠀
⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠈⠈⠀⠠⠐⠀⠅⠨⠨⢐⢑⠥⡑⡌⡪⡪⣝⢵⢳⢱⢕⠕⢅⢇⢗⢵⡫⡧⡳⣕⣗⢵⣣⢺⣰⡳⣝⣗⢽⡪⡗⣝⢕⢕⢕⠜⡌⣲⢝⢎⢎⢌⠢⡣⠣⡑⠌⡂⠢⠡⡊⡆⣗⢕⢕⠕⡕⢕⢕⢕⢅⠂⠅⠄⠅⢂⠁⢂⠀⠀⡀⠀⠄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠂⠀⠌⠐⠀⡁⠈⡀⠌⡐⢔⠬⡸⡸⡸⡪⡪⡪⣣⡫⡣⢃⠕⡸⡱⡳⡙⢮⡫⣞⢮⢏⠾⡵⡳⡝⡮⣗⢽⣪⡳⣣⢣⢣⢱⢑⣕⢗⡕⡇⡣⠢⡱⡑⢕⠅⢕⠨⡘⢌⢢⢯⢎⡎⡆⡇⡣⢱⢑⠕⢌⠪⡠⠁⢂⠀⠐⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⡀⠄⢀⢂⠆⡣⡣⢃⠣⡑⢅⠣⡃⡇⡗⣕⢗⡕⠅⡆⡇⡏⣎⢢⢡⢹⡪⡗⡕⡕⡽⡸⣪⡳⡳⣹⢲⢹⢰⢱⢑⢅⢧⢳⢕⢕⢕⢌⠪⡸⡨⢢⢃⠅⡊⢔⢕⢝⢎⢇⡇⡇⡕⢌⠌⡆⠪⢐⠡⢂⠅⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠄⠀⠀⠀⠀⠁⠀⠀⠀⠈⠀⡀⢀⠄⢅⢢⠨⡂⡊⡢⡑⢌⠆⡇⡣⠣⡑⢜⢜⢎⡇⡇⡎⡎⣜⢔⢕⢸⡸⣕⢝⢮⢪⢸⢜⢜⢕⢵⠱⣑⠥⡣⡱⡕⣕⢕⢕⢕⠕⢔⢡⠣⡊⡢⠢⡑⢌⠢⡑⢜⢕⢕⢕⠕⡕⡡⢑⢌⢊⠐⡈⠐⠁⢂⠠⠀⠁⠀⠄⠐⠀⠀⠀⢀⠀⠀⠀⡀
⠀⠀⠀⠀⠀⠀⢀⠀⠀⠄⠂⠠⠁⠐⠐⠈⠐⠐⠑⠐⡁⡎⡎⡖⡕⣌⢆⢕⢜⡜⡜⡜⣜⢵⡱⣕⢵⢝⢮⣢⡫⡮⡪⣎⢮⢪⢪⢎⢇⢣⢣⢣⢝⢮⢺⢜⢎⢎⡎⡇⢕⢑⢜⢜⢐⠜⢌⠪⢐⠁⡊⢜⢜⢜⠜⠌⡂⡊⠔⠨⢂⢂⠐⠀⠂⠀⠀⠀⠀⠁⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠈⡀⠡⠈⠢⡑⢌⠪⡘⡜⢜⢕⢇⠇⡇⠇⡇⡇⡧⡳⡵⡹⣪⢮⢺⢕⢧⡪⡢⡱⣱⢹⢸⢨⢪⣪⢫⢳⢱⡱⡱⡱⡱⡡⡡⡣⡱⡂⢆⢇⢃⠑⠄⠂⢌⠪⢢⠡⠣⡁⢂⠐⠐⡀⠌⢐⠀⠁⠀⠠⠈⠀⠠⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀
⠀⠀⠀⠀⢀⠀⠂⠀⠀⠄⠀⠀⡀⠄⠂⠀⢀⠀⠄⠂⠅⡂⠅⠢⡑⢜⠸⡘⡔⣑⢌⢎⢎⡚⡮⢯⢯⢎⢆⢇⢫⣳⢕⡕⡇⡏⡎⡎⣎⢎⢧⢳⡹⣸⢜⢜⢜⢼⠸⡐⡕⡕⡕⢌⢆⢇⠆⢅⠡⠈⠠⢊⢂⠊⢔⠀⢂⠈⠄⠠⠐⠐⢈⠀⠠⢀⠁⡀⠁⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠠
⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠊⠌⠂⢐⢈⠐⢌⠢⠡⡡⡣⢣⠣⡳⡣⢣⣫⡳⣫⢯⣇⣇⡇⣗⡝⡮⡣⡲⣝⢎⢊⢎⢮⡪⡞⡕⣕⢵⡫⡪⢪⢸⢸⢸⢸⢸⢸⢸⠨⡐⠠⢁⠨⠐⠄⡑⡐⢈⠠⠐⠐⢀⠂⠐⠀⠠⠁⠠⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠈⠀⠠⠐⠈⠄⠂⠡⢂⠑⡑⠌⠌⠢⡃⡕⡮⡳⡵⡝⣞⢗⣗⣗⢯⢞⡮⡳⣹⢽⢐⠅⡢⢱⡓⡵⡹⡸⢸⠸⡜⡌⣎⢎⢎⢎⢎⢎⢎⢎⢪⠠⠡⠀⠄⠨⠐⡀⢊⠠⠐⠈⠠⠀⠂⡁⢀⠂⠂⠀⠄⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠈⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠂⠀⠄⠀⠈⠀⠂⠡⡈⠠⠀⠀⠄⢂⢁⠢⡑⡅⡇⡇⡏⢎⢗⢇⢗⢝⠕⢯⡺⡕⡇⡕⢌⢢⠣⡪⡊⡪⠨⠪⣘⢜⠜⡜⡌⡎⣎⢎⢎⠎⡢⡱⠨⠐⠠⠈⡀⠡⠐⡀⢂⢈⠐⢀⠨⠠⢀⢐⠀⡈⠀⡀⠀⠀⠂⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠄⠀⢀⠀⠀⠠⠀⠀⠀⠈⠀⢁⠠⠀⠐⠀⢀⢁⠂⠠⡱⡑⡌⠜⠨⠠⡑⢅⠣⡳⡱⡱⡱⣸⢪⢪⢪⢢⢣⢣⠣⢪⢸⠨⠣⡑⠕⡕⢕⢕⢕⢕⢕⠅⡕⢜⠐⢅⠡⠐⢀⠐⠀⠅⠐⠠⠐⢈⠀⠠⠑⠠⠂⠂⠀⠠⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠂⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⡀⠐⠀⠀⡀⠈⢀⠈⠀⠀⡀⠂⠁⠀⠄⠀⢠⠃⢈⠠⠡⢑⠐⢌⢢⢑⠨⡪⡪⡚⡜⡵⡕⡕⡕⡕⡱⡩⡪⡢⠣⡃⡪⢨⢊⢎⠢⢣⠱⡡⡱⢘⢔⢁⢂⠊⡈⠄⠠⠁⠌⡈⠄⡑⡐⢌⠠⠡⢁⠂⠀⠂⠀⠀⠀⠀⠀⠠⠐⠈⠀⠀⠀⠀⡀⠄⠂
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠄⠀⠀⠀⢀⠁⠀⠀⠀⠀⢈⠀⠀⠁⠀⠠⠠⡑⢅⢑⠔⡡⡡⠱⡐⡅⡣⡪⣪⢳⡱⡑⡎⡎⡪⡸⡘⢌⢪⢐⠕⡡⢂⠕⠡⠊⠌⡊⠪⡊⢆⢂⢂⠂⠌⠠⠈⡀⢂⢂⠐⡨⡐⠨⢀⠀⡀⠁⠀⠂⠀⠂⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠄⢀⠀⠀⠠⠀⠀⢀⠀⠀⠀⠁⠀⠈⠌⡂⠅⡂⡂⡂⠅⡊⡐⢜⢜⢌⢗⡕⡕⢕⠌⠂⠅⠅⡑⢐⠅⢌⠐⡐⠄⠁⠅⠂⠌⠌⣊⠢⡃⢕⠌⡐⢀⠡⠀⠂⡂⡂⠔⠠⠁⠄⠠⠀⡀⠁⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠀⡁⢂⠡⠐⠀⡂⠅⡂⠪⢐⠡⢃⠣⡣⡑⠅⡂⠄⢅⢂⠐⠐⡈⠐⠀⡂⢁⠈⢈⠀⠡⠨⠐⢅⠪⡐⡑⢄⠂⠐⢈⠀⠂⠢⢁⠡⠈⡀⠂⠁⠀⢈⠀⠀⡀⠐⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠄⠁⠀⢂⠁⠌⠌⠐⠐⠀⠂⢕⠨⠐⡀⠌⠀⡂⠄⠁⡀⠂⠁⠐⡀⠐⡀⠐⠈⠄⠅⡑⠌⡂⡊⡢⠨⢈⠠⢈⠈⠄⡁⠀⠠⠀⠂⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⠀⠀
⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠠⠐⠀⠀⠀⠄⠈⠀⠂⠁⠀⠄⠀⠀⢈⠀⡁⠈⡀⠅⡂⠐⠀⠄⠀⠄⠐⠀⠠⠐⠈⠄⠐⠀⠐⠀⠌⠠⠁⠄⠡⠐⢐⠨⠨⠐⢈⠔⢈⢐⠀⠅⡀⠀⠐⠈⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⡀⠀⠀⠠⠀⠄⠀⡀⠐⠨⢀⠡⠐⠀⠀⠂⠁⠐⠀⠁⠐⠀⠁⠈⡀⠂⠁⠐⠀⢈⠠⠀⠄⠁⠀⠀⠈⠐⠠⢁⠢⠐⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠂⠀⠀⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠈⠄⠠⠐⠀⠐⠀⠀⠀⠐⠀⠀⠄⠂⠁⠀⠀⠈⠀⠠⠀⠀⠄⠀⠀⠀⠐⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⢀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠐⠀⠁⠀⠀⠄⠀⠀⠡⠐⠀⠀⠀⡀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠄⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠐⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠐⠀⠁⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⠈⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠁⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⡀⠀⠐⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠐⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠈⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠈⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀`;

        if (fairyArt) {
            fairyArt.textContent = fairyASCII;
        }
        
        function updateLoading(percent) {
            // Update progress text
            if (loadingProgressText) {
                loadingProgressText.textContent = `Loading... ${Math.round(percent)}%`;
            }
            
            // Update gradient rotation based on loading progress
            const gradient = document.querySelector('.fairy-gradient');
            if (gradient) {
                const rotation = (percent / 100) * 360;
                gradient.style.transform = `translate(-25%, -25%) rotate(${rotation}deg)`;
            }
            if (percent >= 100 && loadingScreen) {
                setTimeout(() => {
                    loadingScreen.classList.add('hidden');
                }, 500);
            }
        }

        // Start loading immediately
        updateLoading(10);

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = null; // Transparent so chartreuse shows through
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            premultipliedAlpha: false
        });
        renderer.setClearColor(0x000000, 0); // Fully transparent
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.domElement.style.backgroundColor = 'transparent';
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        updateLoading(40);

        // Camera position - view the data flow from side
        camera.position.set(0, 5, 20);
        camera.lookAt(0, 0, 0);

        // Lighting - two-tone (warm left, cool right)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // Warm light for MATLAB side (left)
        const matlabLight = new THREE.PointLight(0xff6b35, 1.5, 30);
        matlabLight.position.set(-15, 5, 0);
        scene.add(matlabLight);

        // Cool light for H5 side (right)
        const h5Light = new THREE.PointLight(0x667eea, 1.5, 30);
        h5Light.position.set(15, 5, 0);
        scene.add(h5Light);

        // Conversion zone light (center)
        const conversionLight = new THREE.SpotLight(0xfbbf24, 2, 20, Math.PI / 4, 0.5);
        conversionLight.position.set(0, 10, 0);
        conversionLight.target.position.set(0, 0, 0);
        scene.add(conversionLight);
        scene.add(conversionLight.target);

        updateLoading(50);

        // Color schemes
        const matlabColors = [0xff6b35, 0xff8c42, 0xffa07a]; // Orange/red
        const h5Colors = [0x667eea, 0x764ba2, 0x9b59b6]; // Purple/blue
        const conversionColors = [0xfbbf24, 0xf59e0b, 0xf97316]; // Yellow/orange

        // MATLAB side: Hierarchical data structures (genotype → ESET → experiment)
        const matlabStructures = [];
        const structureGroups = [];

        // Create individual larvae above title (like GitHub homepage)
        const larvaCount = 12;
        const matlabLarvae = [];
        
        // Larva colors matching GitHub homepage style
        const larvaColors = [
            0x7FFF00, // Chartreuse
            0x7df9ff, // Electric blue
            0x00ff88, // Mint
            0xffffff, // White
            0xffff00, // Yellow
            0xff00ff, // Magenta
            0x00ffff, // Cyan
            0xff6600, // Orange
            0x9933ff  // Purple
        ];
        
        function createGitHubLarva(color) {
            // Create segmented larva using CatmullRomCurve3 (like GitHub homepage)
            const larvaLength = 0.8 + Math.random() * 0.4;
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(larvaLength * 0.3, 0, 0),
                new THREE.Vector3(larvaLength * 0.6, 0, 0),
                new THREE.Vector3(larvaLength, 0, 0)
            ]);
            
            const points = curve.getPoints(20);
            const larvaGeometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // Create glowing effect matching GitHub homepage
            const larvaMaterial = new THREE.LineBasicMaterial({
                color: color,
                linewidth: 3,
                opacity: 0.85,
                transparent: true
            });
            
            const larva = new THREE.Line(larvaGeometry, larvaMaterial);
            
            // Add glow effect using point light
            const glowLight = new THREE.PointLight(color, 0.5, 1);
            glowLight.position.set(larvaLength/2, 0, 0);
            larva.add(glowLight);
            
            // Add motion properties
            larva.userData = {
                velocity: 0.02 + Math.random() * 0.03,
                direction: Math.random() * Math.PI * 2,
                lastTurn: 0,
                turnInterval: 20 + Math.random() * 40,
                wigglePhase: Math.random() * Math.PI * 2,
                wiggleFrequency: 0.2 + Math.random() * 0.3,
                wiggleAmount: 0.05 + Math.random() * 0.1,
                size: 0.3 + Math.random() * 0.2,
                trajectoryPoints: [],
                trajectoryColor: new THREE.Color(color),
                lastTrajectoryUpdate: 0,
                trajectoryUpdateInterval: 3
            };
            
            // Resize larva
            larva.scale.set(larva.userData.size, larva.userData.size, larva.userData.size);
            
            return larva;
        }
        
        for (let i = 0; i < larvaCount; i++) {
            const color = larvaColors[Math.floor(Math.random() * larvaColors.length)];
            const larva = createGitHubLarva(color);
            
            // Position above title in a spread pattern
            const angle = (i / larvaCount) * Math.PI * 2;
            const radius = 3 + Math.random() * 2;
            larva.position.set(
                Math.cos(angle) * radius,
                8 + Math.sin(angle) * radius * 0.3 + (Math.random() - 0.5) * 2,
                -5 + (Math.random() - 0.5) * 2
            );
            
            // Orient larva
            larva.lookAt(0, 0, 0);
            const randomRotation = Math.random() * Math.PI * 2;
            larva.rotateOnAxis(new THREE.Vector3(0, 0, 1), randomRotation);
            
            scene.add(larva);
            matlabLarvae.push(larva);
            
            // Store for particle emission
            matlabStructures.push({
                mesh: larva,
                type: 'larva',
                group: null,
                lastEmission: 0
            });
        }

        updateLoading(60);

        // H5 side: Biased random walk clusters shaped like larvae (right side)
        const h5Structures = [];
        const h5Tree = new THREE.Group();
        h5Tree.position.x = 12;
        h5Tree.position.y = 0;

        // Create boid swarm system for larvae
        const boidCount = 15;
        const boids = [];
        
        // Larva shape: elongated capsule/sphere
        function createLarvaShape() {
            const larvaGroup = new THREE.Group();
            
            // Main body (elongated sphere)
            const bodyGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const bodyMat = new THREE.MeshPhysicalMaterial({
                color: h5Colors[0],
                emissive: h5Colors[0],
                emissiveIntensity: 0.4,
                metalness: 0.3,
                roughness: 0.1,
                clearcoat: 1.0,
                transmission: 0.3,
                opacity: 0.9,
                transparent: true
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.scale.set(1, 2, 1); // Elongate vertically
            larvaGroup.add(body);
            
            // Head (slightly larger)
            const headGeo = new THREE.SphereGeometry(0.18, 8, 8);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 0.3;
            larvaGroup.add(head);
            
            return larvaGroup;
        }
        
        // Initialize larvae in clusters
        const clusterCenters = [
            new THREE.Vector3(10, 3, 0),
            new THREE.Vector3(12, -2, 0),
            new THREE.Vector3(14, 1, 0)
        ];
        
        for (let i = 0; i < boidCount; i++) {
            const larva = createLarvaShape();
            // Assign to random cluster
            const clusterIdx = Math.floor(Math.random() * clusterCenters.length);
            const center = clusterCenters[clusterIdx];
            larva.position.set(
                center.x + (Math.random() - 0.5) * 2,
                center.y + (Math.random() - 0.5) * 2,
                center.z + (Math.random() - 0.5) * 1
            );
            
            const boid = {
                mesh: larva,
                position: larva.position.clone(),
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                ),
                type: 'larva'
            };
            
            h5Tree.add(larva);
            boids.push(boid);
            h5Structures.push({ mesh: larva, type: 'larva', boid: boid });
        }

        scene.add(h5Tree);

        updateLoading(70);

        // Larva particle system for data flow
        const larvaParticleCount = 50;
        const larvaParticles = [];
        const larvaVelocities = [];
        const larvaStates = [];
        const larvaLifetimes = [];
        const maxLifetime = 8.0;

        const matlabColor = new THREE.Color(matlabColors[0]);
        const h5Color = new THREE.Color(h5Colors[0]);
        const conversionColor = new THREE.Color(conversionColors[0]);

        function createLarvaParticle(color) {
            // Use line-based style for particles too (matching GitHub homepage)
            const larvaLength = 0.3 + Math.random() * 0.2;
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(larvaLength * 0.3, 0, 0),
                new THREE.Vector3(larvaLength * 0.6, 0, 0),
                new THREE.Vector3(larvaLength, 0, 0)
            ]);
            
            const points = curve.getPoints(10);
            const larvaGeometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const larvaMaterial = new THREE.LineBasicMaterial({
                color: color,
                linewidth: 2,
                opacity: 0.8,
                transparent: true
            });
            
            const larva = new THREE.Line(larvaGeometry, larvaMaterial);
            
            return larva;
        }

        for (let i = 0; i < larvaParticleCount; i++) {
            // Start particles at MATLAB structures
            const source = matlabStructures[Math.floor(Math.random() * matlabStructures.length)];
            const larva = createLarvaParticle(matlabColor);
            
            larva.position.set(
                source.mesh.position.x + source.group.position.x,
                source.mesh.position.y + source.group.position.y,
                source.mesh.position.z + source.group.position.z
            );
            
            larvaVelocities.push(new THREE.Vector3(
                Math.random() * 0.08 + 0.03,
                (Math.random() - 0.5) * 0.05,
                (Math.random() - 0.5) * 0.05
            ));
            
            larvaStates.push(0);
            larvaLifetimes.push(Math.random() * maxLifetime);
            
            scene.add(larva);
            larvaParticles.push(larva);
        }

        updateLoading(75);
        updateLoading(80);

        // Post-processing - ensure transparency
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        renderPass.clear = true;
        renderPass.clearColor = 0x7fff00; // Chartreuse
        renderPass.clearAlpha = 0; // Transparent
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);

        const outputPass = new OutputPass();
        composer.addPass(outputPass);
        
        // Force renderer to not clear with black
        renderer.autoClear = false;

        updateLoading(90);

        // Mouse interaction - wind effect
        const mouse = new THREE.Vector2();
        const mouseWorld = new THREE.Vector3();
        const windStrength = 2.0;
        const windRadius = 12;
        let mouseWorldPos = new THREE.Vector3(0, 0, 0);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Convert normalized mouse to world coordinates
            // Using camera's view direction and screen space
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            mouseWorldPos = camera.position.clone().add(dir.multiplyScalar(distance));
        });

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 50;

        updateLoading(95);

        // Animation
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            const delta = clock.getDelta();

            // Animate MATLAB larvae above title (matching GitHub homepage style)
            matlabLarvae.forEach((larva, idx) => {
                const ud = larva.userData;
                if (!ud) return;
                
                // Update wiggle phase
                ud.wigglePhase += ud.wiggleFrequency || 0.2;
                
                // Decide if it's time to change direction
                if (ud.lastTurn !== undefined) {
                    ud.lastTurn += 1;
                    if (ud.turnInterval && ud.lastTurn > ud.turnInterval) {
                        ud.direction += (Math.random() - 0.5) * Math.PI;
                        ud.lastTurn = 0;
                        ud.turnInterval = 20 + Math.random() * 40;
                    }
                }
                
                // Apply small random direction changes
                if (ud.direction) ud.direction += (Math.random() - 0.5) * 0.1;
                
                // Add wiggle effect to direction
                const wiggleDirection = ud.direction + (ud.wiggleAmount ? Math.sin(ud.wigglePhase) * ud.wiggleAmount : 0);
                
                // Move in a gentle floating pattern
                larva.position.y += Math.sin(elapsedTime * 0.5 + idx) * 0.01;
                larva.position.x += Math.cos(wiggleDirection) * (ud.velocity || 0.02) * 0.1;
                larva.position.z += Math.sin(wiggleDirection) * (ud.velocity || 0.02) * 0.1;
                
                // Rotate larva to face direction
                if (wiggleDirection !== undefined) {
                    larva.rotation.z = wiggleDirection;
                }
                
                // Update trajectory
                if (ud.lastTrajectoryUpdate !== undefined && ud.trajectoryUpdateInterval) {
                    ud.lastTrajectoryUpdate++;
                    if (ud.lastTrajectoryUpdate >= ud.trajectoryUpdateInterval) {
                        ud.lastTrajectoryUpdate = 0;
                        
                        if (ud.trajectoryPoints) {
                            ud.trajectoryPoints.push(larva.position.clone());
                            
                            // Limit trajectory length
                            if (ud.trajectoryPoints.length > 20) {
                                ud.trajectoryPoints.shift();
                            }
                            
                            // Update trajectory line
                            if (ud.trajectoryLine) {
                                ud.trajectoryLine.geometry.dispose();
                                ud.trajectoryLine.geometry = new THREE.BufferGeometry().setFromPoints(ud.trajectoryPoints);
                            } else if (ud.trajectoryPoints.length > 1 && ud.trajectoryColor) {
                                const material = new THREE.LineBasicMaterial({
                                    color: ud.trajectoryColor,
                                    transparent: true,
                                    opacity: 0.6,
                                    linewidth: 2
                                });
                                
                                const geometry = new THREE.BufferGeometry().setFromPoints(ud.trajectoryPoints);
                                const line = new THREE.Line(geometry, material);
                                ud.trajectoryLine = line;
                                scene.add(line);
                            }
                        }
                    }
                }
                
                // Gentle pulsing opacity
                const pulse = 0.7 + Math.sin(elapsedTime * 2 + idx) * 0.15;
                if (larva.material) {
                    larva.material.opacity = pulse;
                }
            });

            // Animate H5 biased random walk clusters (larvae)
            const clusterRadius = 4;
            const randomWalkStrength = 0.02;
            const biasStrength = 0.01;
            const clusterCenters = [
                new THREE.Vector3(10, 3, 0),
                new THREE.Vector3(12, -2, 0),
                new THREE.Vector3(14, 1, 0)
            ];
            
            // Group larvae into clusters
            const clusters = [];
            clusterCenters.forEach((center, cIdx) => {
                clusters.push({
                    center: center,
                    members: []
                });
            });
            
            // Assign larvae to nearest cluster
            h5Structures.forEach((struct, idx) => {
                if (struct.boid) {
                    let nearestCluster = 0;
                    let nearestDist = Infinity;
                    clusterCenters.forEach((center, cIdx) => {
                        const dist = struct.boid.position.distanceTo(center);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestCluster = cIdx;
                        }
                    });
                    clusters[nearestCluster].members.push(struct);
                }
            });
            
            // Update each cluster with biased random walk
            clusters.forEach((cluster, cIdx) => {
                // Update cluster center with random walk
                const randomStep = new THREE.Vector3(
                    (Math.random() - 0.5) * randomWalkStrength,
                    (Math.random() - 0.5) * randomWalkStrength,
                    (Math.random() - 0.5) * randomWalkStrength * 0.5
                );
                cluster.center.add(randomStep);
                
                // Bias cluster center back toward origin area
                const bias = cluster.center.clone().multiplyScalar(-biasStrength);
                cluster.center.add(bias);
                
                // Update each member of cluster
                cluster.members.forEach((struct) => {
                    const boid = struct.boid;
                    
                    // Random walk component
                    const randomWalk = new THREE.Vector3(
                        (Math.random() - 0.5) * randomWalkStrength * 2,
                        (Math.random() - 0.5) * randomWalkStrength * 2,
                        (Math.random() - 0.5) * randomWalkStrength
                    );
                    
                    // Bias toward cluster center
                    const toCenter = new THREE.Vector3()
                        .subVectors(cluster.center, boid.position)
                        .normalize()
                        .multiplyScalar(biasStrength * 5);
                    
                    // Combine forces
                    boid.velocity.add(randomWalk);
                    boid.velocity.add(toCenter);
                    
                    // Damping
                    boid.velocity.multiplyScalar(0.95);
                    
                    // Limit speed
                    const maxSpeed = 0.05;
                    if (boid.velocity.length() > maxSpeed) {
                        boid.velocity.normalize().multiplyScalar(maxSpeed);
                    }
                    
                    // Keep within cluster radius
                    const distFromCenter = boid.position.distanceTo(cluster.center);
                    if (distFromCenter > clusterRadius) {
                        const backToCenter = new THREE.Vector3()
                            .subVectors(cluster.center, boid.position)
                            .normalize()
                            .multiplyScalar(0.02);
                        boid.velocity.add(backToCenter);
                    }
                    
                    // Update position
                    boid.position.add(boid.velocity);
                    struct.mesh.position.copy(boid.position);
                    
                    // Rotate larva to face direction of movement
                    if (boid.velocity.length() > 0.001) {
                        struct.mesh.lookAt(boid.position.clone().add(boid.velocity));
                    }
                });
            });

            // Apply wind force to MATLAB larvae
            matlabLarvae.forEach((larva) => {
                const larvaWorldPos = new THREE.Vector3();
                larva.getWorldPosition(larvaWorldPos);
                const distance = larvaWorldPos.distanceTo(mouseWorldPos);
                
                if (distance < windRadius && distance > 0.1) {
                    const force = (1 - distance / windRadius) * windStrength * delta;
                    const direction = new THREE.Vector3()
                        .subVectors(larvaWorldPos, mouseWorldPos)
                        .normalize();
                    larva.position.add(direction.multiplyScalar(force));
                }
            });

            // Apply wind force to H5 structures
            h5Structures.forEach((struct) => {
                const structWorldPos = new THREE.Vector3();
                struct.mesh.getWorldPosition(structWorldPos);
                const distance = structWorldPos.distanceTo(mouseWorldPos);
                
                if (distance < windRadius && distance > 0.1) {
                    const force = (1 - distance / windRadius) * windStrength * delta;
                    const direction = new THREE.Vector3()
                        .subVectors(structWorldPos, mouseWorldPos)
                        .normalize();
                    struct.mesh.position.add(direction.multiplyScalar(force));
                }
            });

            // Update larva particles (data flow)
            for (let i = 0; i < larvaParticles.length; i++) {
                const larva = larvaParticles[i];
                const velocity = larvaVelocities[i];
                const particlePos = larva.position.clone();
                
                // Apply wind to larvae
                const distance = particlePos.distanceTo(mouseWorldPos);
                if (distance < windRadius && distance > 0.1) {
                    const force = (1 - distance / windRadius) * windStrength * 0.3 * delta;
                    const direction = new THREE.Vector3()
                        .subVectors(particlePos, mouseWorldPos)
                        .normalize();
                    velocity.add(direction.multiplyScalar(force * 5));
                }
                
                // Update lifetime
                larvaLifetimes[i] += delta;
                
                // Add slight turbulence
                velocity.y += (Math.random() - 0.5) * 0.005 * delta;
                velocity.z += (Math.random() - 0.5) * 0.005 * delta;
                
                // Update position
                larva.position.add(velocity.clone().multiplyScalar(delta * 10));
                
                // Fade out based on lifetime
                const age = larvaLifetimes[i] / maxLifetime;
                const opacity = Math.max(0.3, 1 - age * 0.7);
                
                // Update material opacity
                larva.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = opacity;
                    }
                });
                
                // State transitions based on X position
                if (larva.position.x < -5 && larvaStates[i] === 0) {
                    // In MATLAB zone
                    larvaStates[i] = 0;
                } else if (larva.position.x >= -5 && larva.position.x < 5 && larvaStates[i] < 2) {
                    // In conversion zone - accelerate and change color
                    larvaStates[i] = 1;
                    velocity.x *= 1.01;
                    
                    // Transition color
                    const t = (larva.position.x + 5) / 10;
                    const color = new THREE.Color().lerpColors(
                        matlabColor,
                        conversionColor,
                        t
                    );
                    larva.children.forEach(child => {
                        if (child.material) {
                            child.material.color = color;
                            child.material.emissive = color;
                        }
                    });
                } else if (larva.position.x >= 5 && larvaStates[i] < 2) {
                    // Arrived at H5 zone
                    larvaStates[i] = 2;
                    larva.children.forEach(child => {
                        if (child.material) {
                            child.material.color = h5Color;
                            child.material.emissive = h5Color;
                        }
                    });
                }
                
                // Rotate larva to face direction of movement
                if (velocity.length() > 0.001) {
                    larva.lookAt(larva.position.clone().add(velocity));
                }
                
                // Reset larvae that have passed through or expired
                if (larva.position.x > 15 || larvaLifetimes[i] > maxLifetime) {
                    // Respawn at random MATLAB structure
                    const source = matlabStructures[Math.floor(Math.random() * matlabStructures.length)];
                    larva.position.set(
                        source.mesh.position.x + source.group.position.x,
                        source.mesh.position.y + source.group.position.y,
                        source.mesh.position.z + source.group.position.z
                    );
                    
                    velocity.set(
                        Math.random() * 0.08 + 0.03,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05
                    );
                    larvaStates[i] = 0;
                    larvaLifetimes[i] = 0;
                    
                    larva.children.forEach(child => {
                        if (child.material) {
                            child.material.color = matlabColor;
                            child.material.emissive = matlabColor;
                            child.material.opacity = 0.9;
                        }
                    });
                }
            }

            // Animate lights
            matlabLight.intensity = 1.5 + Math.sin(elapsedTime) * 0.3;
            h5Light.intensity = 1.5 + Math.sin(elapsedTime + Math.PI) * 0.3;
            conversionLight.intensity = 2 + Math.sin(elapsedTime * 2) * 0.5;

            // Camera subtle movement
            camera.position.x += Math.sin(elapsedTime * 0.1) * 0.01;
            camera.position.y += Math.cos(elapsedTime * 0.15) * 0.01;

            controls.update();
            
            // Clear with chartreuse background showing through
            renderer.setClearColor(0x7fff00, 0); // Chartreuse but fully transparent
            renderer.clearColor();
            composer.render();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start animation
        animate();
        
        // Complete loading after animation starts
        updateLoading(100);
        
        // Ensure loading screen hides after a short delay
        setTimeout(() => {
            if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
                loadingScreen.classList.add('hidden');
            }
        }, 500);

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Error:', e);
            // Hide loading screen on error
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
        });
    </script>
</body>
</html>
